# TURBO RAILS TUTORIAL

We are building a simple application based on this tutorial.

<a href="https://www.hotrails.dev/turbo-rails">Link Tutorial</a>

___
## Chapter 0 - Introduction

- Rails 7.0.0
- Ruby 3.2.1

- Docker
    - docker-compose up -d

    - Run postgres on port 5450
    - Run redis on port 6379

- Install the dependencies and create the database

    ```ruby
    bin/setup
    ```

- Run the rails server

    ```ruby
    bin/dev
    ```
    based on the file **Procfile.dev**
___

## Chapter 1 - CRUD

Using the TDD - development based on tests.

- Creating Tests of our application

    ```ruby
    bin/rails g system_test quotes
    ```

    - First CRUD Test - CREATE
        - Visit the page index
        - See the name Quotes
        - Click on New Quote
        - Fill name and click on Create quote
        - Return of the Quote page with the new name created.

    - use Rails fixtures to create fake data for our tests

        ```ruby
        # test/fixtures/quotes.yml
        ```

    - Second CRUD Test - READ

    - Third CRUD Test - UPDATE

    - Fourth CRUD Test - DELETE

- Creating Model Quote

    ```ruby
    rails generate model Quote name:string
    ```

    ```ruby
    bin/rails db:migrate
    ```

- Creating Controller Quotes

    ```ruby
    bin/rails generate controller Quotes
    ```

    - Create Action:
        - index
        - show
        - new
        - create
        - edit
        - update
        - destroy

- Creating Views

    - Based on Actions:
        - index.html.erb
        - new.html.erb
        - edit.html.erb
        - show.html.erb

    - Partial:
        ### partial to delete or edit each quote of our list
        - _quote.html.erb

        ### partial for use form in many places of our application
        - _form.html.erb

            this partial especially, will use the benefit of the gem **simple_form**

- Run Test

    ```ruby
    bin/rails test:system
    ```

- Fixture and seed:

    Fixture was be used to create fake data for test.
    To development we use seed file.
    To reuse the fixture file on the seed file, we will add the following code on the seed file:

    ```ruby
    puts "\n== Seeding the database with fixtures =="
    system("bin/rails db:fixtures:load")
    ```

- Run Seed

    ```ruby
    bin/rails db:seed
    ```
___

## Chapter 2 - CSS files

- Based on the <a href="https://en.bem.info/methodology/">BEM Methodology</a>

- Our structure:

    * **application.sass.scss** manifest file to import all our styles.
    * **mixins/** where we'll add Sass mixins.
    * **config/** where we'll add our variables and global styles.
    * **components/** folder where we'll add our components.
    * **layouts/** where we'll add our layouts.
___

## Chapter 3 - Turbo Drive

Objective: speeds up application, converting all links and form into <a href="https://developer.mozilla.org/pt-BR/docs/Web/Guide/AJAX/Getting_Started">AJAX requests</a>.

The <head> of the HTML page wont be changed, only the <body> that will be replace with the response of the AJAX requests, caled when the Turbo Drive **intercepts a click on a link or a submission of a form**.

Because of that form of Turbo works, the rails 7 applications are single-page by default, that means only the <body> of the page are replaced.

- Disabling Turbo Drive
    Some gems not supported Turbo Drive, so on that scenarios it is disabled.

    ```js
    data: { turbo: false }
    ```

    Option to disable Turbo Drive on whole project
    ```js
    // app/javascript/application.js
    import { Turbo } from "@hotwired/turbo-rails"
    Turbo.session.drive = false
    ```

- Reloading the page

A problem with this Turbo's solution is when the <head> is change by some update in the application, by default Turbo will change only the <body>. So it's important to put a element on the application page **data-turbo-track="reload"**

    ```js
    // app/views/layouts/application.html.erb

    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_include_tag "application", "data-turbo-track": "reload", defer: true %>
    ```

- Changing the style of the Turbo Drive progress bar

the browser's default progress bar/loaders won't work as expected anymore, because the Turbo Drives overrides the default behavior of the page.

    - app/assets/stylesheets/components/_turbo_progress_bar.scss
___

## Chapter 4 - Turbo Frame and Turbo Stream templates


- Turbo Frames
    - are independent pieces of a web page that can be appended, prepended, replaced, or removed without a complete page refresh and writing a single line of JavaScript!

    ```ruby
    turbo_frame_tag helper
    ```
    - the turbo_frame_tag helper creates a <turbo-frame> custom element that contains the HTML generated by the content of the block.

    - Rules of Turbo Frame

        - **Rule 1:** When clicking on a link within a Turbo Frame, Turbo expects a frame of the same id on the target page. It will then replace the Frame's content on the source page with the Frame's content on the target page.

        - **Rule 2:** When clicking on a link within a Turbo Frame, if there is no Turbo Frame with the same id on the target page, the frame disappears, and the error Response has no matching <turbo-frame id="name_of_the_frame"> element is logged in the console.

        - **Rules 3:** A link can target another frame than the one it is directly nested in thanks to the data-turbo-frame data attribute.


            **Note:** There is a special frame called _top that represents the whole page. It's not really a Turbo Frame, but it behaves almost like one, so we will make this approximation for our mental model.

    - dom_id helper

    ```ruby
    # If the quote is persisted and its id is 1:
    dom_id(@quote) # => "quote_1"

    # If the quote is a new record:
    dom_id(Quote.new) # => "new_quote"

    # Note that the dom_id can also take an optional prefix argument
    # We will use this later in the tutorial
    dom_id(Quote.new, "prefix") # "prefix_new_quote"
    ```

- Turbo Stream
    - the combination of Turbo Frames and the new TURBO_STREAM format, we will be able to perform precise operations on pieces of our web pages without having to write a single line of JavaScript, therefore preserving the state of our web pages
    - the turbo_stream helper responds to the following methods, so that it can perform the following actions

    ```ruby
    # Remove a Turbo Frame
    turbo_stream.remove

    # Insert a Turbo Frame at the beginning/end of a list
    turbo_stream.append
    turbo_stream.prepend

    # Insert a Turbo Frame before/after another Turbo Frame
    turbo_stream.before
    turbo_stream.after

    # Replace or update the content of a Turbo Frame
    turbo_stream.update
    turbo_stream.replace
    ```


___

## Chapter 5 - Real-time updates with Turbo Streams

- The Turbo Stream format allows, in combination with Action Cable, to make real-time updates to our web pages with just a few lines of code. Real-world applications are, for example, group chats, notifications, or email services.


    ```ruby
    after_create_commit -> {
        broadcast_prepend_later_to "quotes"
        partial: "quotes/quote",
        locals: { quote: self },
        target: "quotes"
    }
    ```

    - **after_create_commit** callback to instruct our Ruby on Rails application that the expression in the lambda should be executed every time a new quote is inserted into the database.

    - **lambda expression** It instructs our Ruby on Rails application that the HTML of the created quote should be broadcasted to users subscribed to the "quotes" stream and prepended to the DOM node with the id of "quotes"
    *broadcast_prepend_to* method will render the quotes/_quote.html.erb partial in the Turbo Stream format with the action prepend and the target "quotes" as specified with the target: "quotes" option


    We need to specify it in the Quotes#index view:

    ```ruby
    #<%# app/views/quotes/index.html.erb %>

    <%= turbo_stream_from "quotes" %>
    ```

    The HTML generated by the turbo_stream_from helper looks like this:

    ```html
    <turbo-cable-stream-source
    channel="Turbo::StreamsChannel"
    signed-stream-name="very-long-string"
    >
    </turbo-cable-stream-source>
    ```

    - **Turbo::StreamsChannel** inside the channel attribute is the name of the Action Cable channel. Turbo Rails always uses this channel, so this attribute is always the same.

    - **signed-stream-name** attribute is the signed version of the "quotes" string we passed as an argument. It is signed to prevent malicious users from tampering with it and receiving HTML from streams they should not have access to


    - In development, your config/cable.yml

        ```ruby
        # config/cable.yml

        development:
        adapter: redis
        url: redis://localhost:6379/1
        ```


- Turbo Streams conventions and syntactic sugar

    ```ruby
    #after_create_commit -> {
        #broadcast_prepend_later_to "quotes"
        # The partial default = to_partial_path on an instance of the model
        # by default in Rails for our Quote model is equal to "quotes/quote"
        # partial: "quotes/quote",

        # The locals default value is equal to { model_name.element.to_sym => self }
        # in the context of our Quote model, is equal to { quote: self }
        # locals: { quote: self }

        # By default, the target option will be equal to model_name.plural
        # Because of that we can drop this line
        # target: "quotes"
    #}

    after_create_commit -> { broadcast_replace_later_to "quotes" }
    ```

- Making broadcasting asynchronous with ActiveJob

    ```ruby - before
    after_create_commit -> { broadcast_prepend_to "quotes" }
    after_update_commit -> { broadcast_replace_to "quotes" }
    after_destroy_commit -> { broadcast_remove_to "quotes" }
    ```

     ```ruby - after
    after_create_commit -> { broadcast_prepend_later_to "quotes" }
    after_update_commit -> { broadcast_replace_later_to "quotes" }
    after_destroy_commit -> { broadcast_remove_to "quotes" }
    ```

    **Note**: The broadcast_remove_later_to method does not exist because as the quote gets deleted from the database, it would be impossible for a background job to retrieve this quote in the database later to perform the job.


- More syntactic sugar

    ```ruby - before
    after_create_commit -> { broadcast_prepend_to "quotes" }
    after_update_commit -> { broadcast_replace_to "quotes" }
    after_destroy_commit -> { broadcast_remove_to "quotes" }
    ```

    ```ruby - after
    # Those three callbacks are equivalent to the following single line
    broadcasts_to ->(quote) { "quotes" }, inserts_by: :prepend
    ```

___

## Chapter 6 - Turbo Streams and security


The Quote, Company, and User models will be related to one another by the following associations:

    - A user belongs to a company
    - A quote belongs to a company
    - A company has many users
    - A company has many quotes

    ```ruby
    rails g model Company name
    ```

- Adding users to our application with Devise

    ```ruby
    bin/rails generate devise:install
    ```

    ```ruby
    bin/rails generate devise User
    ```

    - The feature to sign in users (:database_authenticatable)
    - The feature to validate the email and password using Devise built-in validations (:validatable)


    **Note**: When logging in with users, you might encounter a redirection bug when submitting an invalid form. This is because the Devise gem does not support Turbo yet (version 4.8.1). The easiest way to prevent this bug is to disable Turbo on Devise forms by setting the data-turbo attribute to false on Devise forms, as we learned in the Turbo Drive chapter.


- Users, companies and, quotes associations

    ```ruby
    bin/rails generate migration add_company_reference_to_quotes company:references
    bin/rails generate migration add_company_reference_to_users  company:references
    ```

- Adding a home page to our application

    1. Users must be authenticated to access the quote editor, and they should only see quotes that belong to their company.

    **ApplicationController** thanks to the Devise method authenticate_user!

    ```ruby
    before_action :authenticate_user!
    ```

    2. Users must be able to navigate to the sign-in form from the home page even when they are not authenticated.

    ```ruby
    before_action :authenticate_user!, unless: :devise_controller?
    ```

    ```ruby
    root to: "pages#home"

    # app/views/pages/home.html.erb

    # app/views/layouts/_navbar.html.erb

    # app/views/layouts/application.html.erb

    # app/assets/stylesheets/components/_navbar.scss

    # app/assets/stylesheets/application.sass.scss
    ```

    Identify user are signed on navbar

    ```ruby
    # app/models/user.rb
    def name
        email.split("@").first.capitalize
    end

    # app/views/layouts/_navbar.html.erb
    <%= current_user.name %>
    ```

    Identify company are signed on navbar

    ```ruby
    # app/controllers/application_controller.rb
    def current_company
        @current_company ||= current_user.company if user_signed_in?
    end
    helper_method :current_company

    # app/views/layouts/_navbar.html.erb
    <%= current_company.name %>
    ```

    To use the current_company method in our views, we need to turn it into a helper. We can do that thanks to the helper_method method

- Fixing our tests

To sign in users in system tests, we will rely on helpers from the Warden gem to avoid coding them ourselves. Devise is built on top of Warden and the Warden::Test::Helpers module contains helpers that will help us login users in our tests thanks to the login_as method


    ```ruby
    # test/application_system_test_case.rb
    include Warden::Test::Helpers

    # test/system/quotes_test.rb
    setup do
        login_as users(:accountant)
        ...
    ```

    The QuotesController#index method should only show the quotes that belong to the current user's company

    ```ruby
    # app/controllers/quotes_controller.rb
    def index
        @quotes = current_company.quotes.ordered
    end

    def create
        # Only this first line changes to make sure the association is created
        @quote = current_company.quotes.build(quote_params)

    def set_quote
        # We must use current_company.quotes here instead of Quote
        # for security reasons
        @quote = current_company.quotes.find(params[:id])
    ```

- Security and Turbo Streams

There is a critical security issue here: test with differents accounts our quote created by the accountant was broadcasted to the eavesdropper user. Those two users belong to different companies and should never gain access to the other company's quotes

This is a Turbo Streams issue. Before using Turbo Streams in production, we first need to understand how security works at a high level. Let's analyze why we have this security breach and how to fix it.

<turbo-cable-stream-source> tag. It was generated by the turbo_stream_from.

```html
    <!-- Accountant's session -->
    <turbo-cable-stream-source
    channel="Turbo::StreamsChannel"
    signed-stream-name="InF1b3RlcyI=--eba9a5055d229db025dd2ed20d069d87c36a2e4191d8fc04971a93c851bb19fc"
    >
    </turbo-cable-stream-source>

    <!-- Eavesdropper's session -->
    <turbo-cable-stream-source
    channel="Turbo::StreamsChannel"
    signed-stream-name="InF1b3RlcyI=--eba9a5055d229db025dd2ed20d069d87c36a2e4191d8fc04971a93c851bb19fc"
    >
    </turbo-cable-stream-source>
```

both signed stream names are the same, but as they are different companies, they need to be differents too.

- Fixing our Turbo Streams security issue


    ```ruby
    # app/models/quote.rb
    broadcasts_to ->(quote) { [quote.company, "quotes"] }, inserts_by: :prepend
    # Users who share broadcastings should have the lambda return an array with the same values


    # app/views/quotes/index.html.erb %>

    <%= turbo_stream_from current_company, "quotes" %>
    ```

___

## Chapter 7 - Flash messages with Hotwire

Now that we have a working CRUD controller for our Quote model, we want to add flash messages to improve the usability of our application

- Add flash message partial

    ```ruby
    # app/views/layouts/_flash.html.erb

    <% flash.each do |flash_type, message| %>
        <div class="flash__message">
            <%= message %>
        </div>
    <% end %>
    ```

- Render on every page of the application

    ```ruby
    # app/views/layouts/application.html.erb
    <div class="flash">
      <%= render "layouts/flash" %>
    </div>
    ```

- Add css

    ```ruby
    # app/assets/stylesheets/components/_flash.scss
    ```

- And animation

    ```ruby
    # app/assets/stylesheets/config/_animations.scss
    ```

However, there is one small glitch with our current implementation. When we hover the mouse on the flash message area, our mouse cursor changes even when the flash message is not visible anymore. This is because even if our flash message has an opacity of zero, it is still present in the DOM and above the rest of the page's content. To solve this problem, we need to remove the flash messages from the DOM when they reach an opacity of zero.

This is where we will add the single line of JavaScript we need in the whole tutorial. We will create a small Stimulus Controller that removes the flash message when the appear-then-fade animation ends.

    ```ruby
    bin/rails generate stimulus removals
      create  app/javascript/controllers/removals_controller.js
       rails  stimulus:manifest:update
    ```

- We dont need the hello controller, we created our application at the beginning of the tutorial:

    ```ruby
    bin/rails destroy stimulus hello
        remove  app/javascript/controllers/hello_controller.js
        rails  stimulus:manifest:update
    ```

- To remove the lines of index.js, if not removed in the last command

    ```ruby
    bin/rails stimulus:manifest:update
    ```

- Implement our Stimulus Controller

    ```ruby
    remove() {
        this.element.remove()
    }
    ```

    ```ruby
    # app/views/layouts/_flash.html.erb

    <% flash.each do |flash_type, message| %>
    <div
        class="flash__message"
        data-controller="removals"
        data-action="animationend->removals#remove"
    >
        <%= message %>
    </div>
    <% end %>
    ```

The HTML snippet above suggests that each flash message is connected to a RemovalsController thanks to the data-controller="removals" data attribute. When the animation ends, the function remove of the RemovalsController is called thanks to the data-action="animationend->removals#remove data attribute.


- Add on the CRUD controller of quotes

    ```ruby
    format.turbo_stream { flash.now[:notice] = "Quote was successfully created." }

    format.turbo_stream { flash.now[:notice] = "Quote was successfully updated." }

    format.turbo_stream { flash.now[:notice] = "Quote was successfully destroyed." }

    ```

- Add if flass on the render in the application.js

    ```ruby
    <div id="flash" class="flash">
      <%= render "layouts/flash" %>
    </div>
    ```

- To remove possible duplicates, we will create a method on the Application Helper:

    ```ruby
    def render_turbo_stream_flash_messages
        turbo_stream.prepend "flash", partial: "layouts/flash"
    end
    ```

- And use on three files of turbo:

    ```ruby
    # app/views/quotes/create.turbo_stream.erb
    # app/views/quotes/update.turbo_stream.erb
    # app/views/quotes/destroy.turbo_stream.erb

    <%= render_turbo_stream_flash_messages %>

    ```

___

## Chapter 8 - Two ways to handle empty states with Hotwire

1. The first one will use Turbo Frames and Turbo Streams

    * The first thing we have to do is display the empty state only when there are no quotes on the page. To do this, let's create an empty state partial that we can then use on the Quotes#index page.

    ```ruby
    # app/views/quotes/_empty_state.html.erb
    ```

    * We can now render this empty state only when the current user has no quote on the Quotes#index page

    ```ruby
    # app/views/quotes/index.html.erb

    <%= turbo_frame_tag Quote.new do %>
        <% if @quotes.none? %>
        <%= render "quotes/empty_state" %>
        <% end %>
    <% end %>
    ```

    * Add styles with css *app/assets/stylesheets/components/_empty_state.scss*
    * Import on *app/assets/stylesheets/application.sass.scss*

2. The second one will use the :only-child CSS pseudo-class

    * move the content of the quotes/empty_state partial to the quotes list

    ```ruby
    # app/views/quotes/index.html.erb

    <%= turbo_frame_tag Quote.new %>

    <%= turbo_frame_tag "quotes" do %>
        <%= render "quotes/empty_state" %>
        <%= render @quotes %>
    <% end %>
    ```

    * Then, we have to use the :only-child pseudo-class in our CSS to show the empty state when it is the only child of the Turbo Frame with id quotes and hide it when it is not:

    ```ruby
    # app/assets/stylesheets/components/_empty_state.scss

    &--only-child {
        display: none;

        &:only-child {
        display: revert;
        }
    }
    ```

    - We use what the BEM methodology calls a modifier here for our .empty-state--only-child CSS class because we want to support the two methods presented in this chapter with the same .empty-state class

    * we need the "Add quote" link to explicitly target the Turbo Frame with the id of new_quote as it is no longer a child of the Turbo Frame. We can achieve this thanks to the data-turbo-frame="new_quote" data attribute

    ```ruby
    # app/views/quotes/_empty_state.html.erb
    <div class="empty-state empty-state--only-child">
    ```

    - reset the content of the destroy.turbo_stream.erb view as we don't need any custom behavior anymore

    - We can now test the behavior in our browser:

    - When we have quotes in the list, the empty state is not visible
    - When we don't have quotes in the list, the empty state is visible
    - The best part is that we could achieve this behavior with CSS only!


___

## Chapter 9 - Another CRUD controller with Turbo Rails

1. Create a model named LineItemDate with a date field and a reference to the quote it belongs to. We add this reference because each line item date belongs to a quote, and each quote has many line item dates

    ```ruby
    bin/rails generate model LineItemDate quote:references date:date
    ```


___

## Chapter 10 - Nested Turbo Frames


___


## Chapter 11 - Adding a quote total with Turbo Frames


___
